import streamlit as st
import os
import zipfile
import shutil
import tempfile
import re # Import regex for parsing
from pathlib import Path
import google.generativeai as genai

# Define readme_content globally as it's used in both package_project and the preview tab
README_CONTENT = """# Generated Streamlit App

This is a Streamlit application generated by Invision Code.AI.

## Setup Instructions:
1.  **Create a virtual environment (optional but recommended):**
    ```bash
    python -m venv venv
    # On macOS/Linux:
    source venv/bin/activate
    # On Windows:
    venv\\Scripts\\activate
    ```
2.  **Install dependencies:**
    ```bash
    pip install -r requirements.txt
    ```
3.  **Set your Gemini API Key (if the app requires it):**
    Edit the `.env` file and replace `YOUR_GEMINI_API_KEY_HERE` with your actual API key.
    You can get an API key from [Google AI Studio](https://aistudio.google.com/app/apikey).
    **Important:** If deploying to Streamlit Cloud, you should add your `GEMINI_API_KEY` to the app's secrets in `.streamlit/secrets.toml` instead of using the `.env` file.
4.  **Run the Streamlit application:**
    ```bash
    streamlit run app.py
    ```
Enjoy your generated app! üöÄ
"""


# ----------------------------------------------------
# Gemini Client (Streamlit settings for API Key)
# ----------------------------------------------------
def get_gemini_client():
    # Configure the API key globally before creating the model
    genai.configure(api_key=st.secrets["GEMINI_API_KEY"])

    # Create the GenerativeModel instance
    model = genai.GenerativeModel(
        model_name="gemini-2.5-flash",
        generation_config={
            "temperature": 0.7,
            "max_output_tokens": 8192,
        },
        safety_settings=[],
    )
    return model

# ----------------------------------------------------
# Generate Code using Gemini
# ----------------------------------------------------
def generate_code(user_input_prompt: str) -> dict:
    client = get_gemini_client()

    # Modified prompt: Ask Gemini to generate ALL required files (app.py, requirements.txt, .env)
    # Using specific markers to help parse the output.
    full_prompt = (
        f"You are an AI code generator. Your task is to generate the complete code for a Streamlit "
        f"application, including its `app.py` file, `requirements.txt` (listing all Python dependencies "
        f"for `pip install`), and an `.env` file for necessary environment variables (if any, "
        f"otherwise provide a placeholder). If the app requires Google Gemini API key, "
        f"include `google-generativeai` in `requirements.txt` and `GEMINI_API_KEY=YOUR_API_KEY` "
        f"in the `.env` file. Ensure `streamlit` and `python-dotenv` are always in `requirements.txt`. "
        f"Strictly adhere to the following output format: use specific markdown code blocks "
        f"with language annotations and a header for each file.\n\n"
        f"--- File: app.py ---\n"
        f"```python\n"
        f"# Your app.py Streamlit code goes here\n"
        f"```\n\n"
        f"--- File: requirements.txt ---\n"
        f"```txt\n"
        f"# Your Python package dependencies go here\n"
        f"```\n\n"
        f"--- File: .env ---\n"
        f"```ini\n" # or 'txt' for general env files
        f"# Your environment variables go here\n"
        f"```\n\n"
        f"Do NOT include any additional explanations, setup instructions, or markdown "
        f"outside of these defined file blocks. Ensure the content inside each block "
        f"is valid for that file type. If a file isn't strictly necessary based on "
        f"the app's description (e.g., no custom env vars), still provide the basic "
        f"structure with standard content.\n\n"
        f"App Description:\n{user_input_prompt}"
    )

    contents = {
        "role": "user",
        "parts": [{"text": full_prompt}],
    }

    response = client.generate_content(contents)
    generated_text = response.text.strip()

    # --- New: Parse Gemini's response into multiple files ---
    files = {}
    # Use regex to find blocks for each file
    # Example: --- File: app.py --- followed by ```python ... ```
    # Updated regex to be more flexible with the code block language tag
    file_pattern = re.compile(r"--- File: ([\w.]+) ---\s*```(?:\w*\s*)?\n(.*?)\n```", re.DOTALL)

    matches = file_pattern.findall(generated_text)

    for filename, content in matches:
        files[filename.strip()] = content.strip()

    # Ensure compulsory files are present, add defaults if Gemini missed them or if they're empty
    if "app.py" not in files or not files["app.py"].strip():
        st.error("Gemini failed to generate `app.py`. Providing a basic default.")
        files["app.py"] = (
            "import streamlit as st\n"
            "import os\n"
            "import dotenv\n" # Added dotenv for local loading
            "dotenv.load_dotenv() # Load environment variables from .env\n\n"
            "st.set_page_config(page_title='My Generated App')\n"
            "st.title('Welcome to your Streamlit App!')\n"
            "st.write('This app was generated by Invision Code.AI. Modify app.py to customize.')\n"
            "if 'GEMINI_API_KEY' in os.environ and os.environ['GEMINI_API_KEY'] != 'YOUR_GEMINI_API_KEY_HERE':\n"
            "    st.success('GEMINI_API_KEY found and likely valid in environment variables.')\n"
            "else:\n"
            "    st.warning('GEMINI_API_KEY not found or is placeholder. Please set it in .env or Streamlit secrets.')\n"
        )

    # Ensure requirements.txt is present and includes basic dependencies
    default_requirements_lines = [
        "streamlit",
        "python-dotenv",
        "google-generativeai"
    ]
    if "requirements.txt" not in files or not files["requirements.txt"].strip():
        st.warning("Gemini did not generate a `requirements.txt` or it was empty. Providing a default.")
        files["requirements.txt"] = "\n".join(default_requirements_lines) + "\n"
    else:
        existing_reqs = set(line.strip().split("==")[0] for line in files["requirements.txt"].splitlines() if line.strip() and not line.strip().startswith("#"))
        for req in default_requirements_lines:
            if req not in existing_reqs:
                files["requirements.txt"] += f"\n{req}"
        # Clean up any potential duplicate blank lines or extra newlines
        unique_reqs = sorted(list(set(line.strip() for line in files["requirements.txt"].splitlines() if line.strip())))
        files["requirements.txt"] = "\n".join(unique_reqs) + "\n"


    # Ensure .env is present with a placeholder for GEMINI_API_KEY
    if ".env" not in files or not files[".env"].strip():
        st.warning("Gemini did not generate a `.env` file or it was empty. Providing a default.")
        files[".env"] = (
            "# Your Gemini API Key goes here.\n"
            "# Get one from: https://aistudio.google.com/app/apikey\n"
            "GEMINI_API_KEY=YOUR_GEMINI_API_KEY_HERE\n"
        )
    elif "GEMINI_API_KEY" not in files[".env"]: # If it generated an .env but missed the key
        # Check if it's not already there and if .env isn't just an empty placeholder
        if files[".env"].strip() == "# Your environment variables go here":
            files[".env"] = (
                "# Your Gemini API Key goes here.\n"
                "# Get one from: https://aistudio.google.com/app/apikey\n"
                "GEMINI_API_KEY=YOUR_GEMINI_API_KEY_HERE\n"
            )
        else:
            files[".env"] += "\n# Add your Gemini API Key here\nGEMINI_API_KEY=YOUR_GEMINI_API_KEY_HERE\n"
            lines = []
            seen_api_key_placeholder = False
            for line in files[".env"].splitlines():
                if "GEMINI_API_KEY=" in line and not seen_api_key_placeholder:
                    # Keep one placeholder, removing potential others
                    lines.append("GEMINI_API_KEY=YOUR_GEMINI_API_KEY_HERE")
                    seen_api_key_placeholder = True
                elif "GEMINI_API_KEY=" in line and seen_api_key_placeholder:
                    continue # Skip subsequent GEMINI_API_KEY lines
                else:
                    lines.append(line)
            files[".env"] = "\n".join(lines).strip() + "\n"
    
    return files

# ----------------------------------------------------
# Package files into zip
# ----------------------------------------------------
def package_project(files: dict) -> str:
    tmpdir = tempfile.mkdtemp()

    # Add all generated files to the temp directory
    for filename, content in files.items():
        # Clean up potential extra # comments at the start of env/req files if present from parsing
        if filename in ["requirements.txt", ".env"]:
            content = re.sub(r"^\s*#\s*Your.*?here\s*\n", "", content, flags=re.IGNORECASE|re.MULTILINE).strip()
            # Ensure it ends with a newline
            if content and not content.endswith('\n'):
                content += '\n'
        elif not content and filename == "requirements.txt": # Handle truly empty requirements.txt gracefully
             content = "\n" # At least one newline
        elif not content and filename == ".env": # Handle truly empty .env gracefully
             content = "\n" # At least one newline

        with open(os.path.join(tmpdir, filename), "w", encoding="utf-8") as f:
            f.write(content)

    # Always include the README.md which gives instructions
    with open(os.path.join(tmpdir, "README.md"), "w", encoding="utf-8") as f:
        f.write(README_CONTENT) # Use the global constant here

    zip_path = os.path.join(tmpdir, "project.zip")
    with zipfile.ZipFile(zip_path, "w") as zipf:
        for root, _, filenames in os.walk(tmpdir):
            for filename in filenames:
                if filename != "project.zip":
                    filepath = os.path.join(root, filename)
                    zipf.write(filepath, arcname=os.path.relpath(filepath, tmpdir))

    return zip_path

# ----------------------------------------------------
# Streamlit Tabs
# ----------------------------------------------------
st.set_page_config(page_title="Invision Code.AI", layout="wide", initial_sidebar_state="collapsed")

# Inject custom CSS for styling (as previously)
st.markdown(
    """
    <style>
    .stApp {
        background-color: #0E1117; /* Dark background matching the image */
        color: white;
    }
    .stButton>button {
        background-color: #262730;
        color: white;
        border: 1px solid #4F525E;
    }
    .stButton>button:hover {
        border-color: #797C8B;
        color: #797C8B;
    }
    h1, h2, h3, h4, h5, h6 {
        color: white;
    }
    .stMarkdown p {
        color: white;
    }
    .streamlit-expanderContent {
        color: white;
    }
    code {
        background-color: #262730; /* Code block background */
        color: #D2A8FF; /* Example code text color */
        border-radius: 5px;
        padding: 0.2em 0.4em;
    }
    div.stCode > code {
        border-radius: 0.5rem; /* Larger border-radius for the whole code block */
        padding: 1rem;
        background-color: #262730;
        overflow-x: auto;
    }
    .stTabs [data-baseweb="tab-list"] button [data-testid="stMarkdownContainer"] p {
        font-size: 1.1em;
    }
    /* Style the active tab text color and border */
    .stTabs [data-baseweb="tab-list"] button[aria-selected="true"] {
        background-color: #1a1a2e; /* slightly lighter dark background for active tab */
        border-bottom-color: #E642A2; /* pink border for active tab */
        border-bottom-width: 2px;
    }
    .stTabs [data-baseweb="tab-list"] button[aria-selected="true"] [data-testid="stMarkdownContainer"] p {
        color: #E642A2; /* pink text for active tab */
        font-weight: bold;
    }
    /* Style inactive tab text color */
    .stTabs [data-baseweb="tab-list"] button[aria-selected="false"] [data-testid="stMarkdownContainer"] p {
        color: #ADADAD; /* grey for inactive tabs */
    }
    .stSpinner > div > span {
        color: white;
    }
    .stWarning {
        background-color: rgba(255, 193, 7, 0.1);
        border-left: 5px solid #ffc107;
        padding: 1rem;
        border-radius: 0.25rem;
    }
    .stError {
        background-color: rgba(220, 53, 69, 0.1);
        border-left: 5px solid #dc3545;
        padding: 1rem;
        border-radius: 0.25rem;
    }
    .stSuccess {
        background-color: rgba(40, 167, 69, 0.1);
        border-left: 5px solid #28a745;
        padding: 1rem;
        border-radius: 0.25rem;
    }
    .stInfo {
        background-color: rgba(23, 162, 184, 0.1);
        border-left: 5px solid #17a2b8;
        padding: 1rem;
        border-radius: 0.25rem;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.markdown("<h1>üí° Invision Code.AI ‚Äî Streamlit Application Generator <a href='https://github.com/your-repo-link-here' style='color: inherit; text-decoration: none;'><span style='font-size:0.7em;'>üîó</span></a></h1>", unsafe_allow_html=True)

tab1, tab2, tab3 = st.tabs(["üí¨ Chat", "üìÇ Code & Download", "üöÄ Preview"])

# --- Tab 1: Chat Interface ---
with tab1:
    st.subheader("Describe the Streamlit app you want to build")
    user_prompt = st.text_area("App Description", height=200, placeholder="E.g., A simple to-do list with add, mark, and delete functionality, using local storage for persistence. (Mention all libraries, custom CSS, or assets needed.)")
    if st.button("‚ú® Generate App Code", use_container_width=True):
        if user_prompt.strip():
            with st.spinner("Generating Streamlit app code with Gemini... This might take a moment."):
                files = generate_code(user_prompt)
                st.session_state["files"] = files
                st.session_state["generation_complete"] = True
                st.success("Code generated! Now go to the 'Code & Download' tab.")
        else:
            st.warning("Please provide a description to generate code.")

# --- Tab 2: Generated Code & Download ---
with tab2:
    st.subheader("Generated Files")
    if "files" in st.session_state and st.session_state["files"]:
        st.info("Here are the generated project files. Download individual files or the whole project as a ZIP.")

        # Display and download buttons for each generated file
        for filename in sorted(st.session_state["files"].keys()): # Sort for consistent display order
            content = st.session_state["files"][filename]
            col1, col2 = st.columns([0.2, 0.8])
            with col1:
                st.download_button(
                    f"‚¨áÔ∏è {filename}",
                    data=content.encode("utf-8"), # Ensure content is bytes for download
                    file_name=filename,
                    mime="text/plain",
                    key=f"download_{filename}"
                )
            with col2:
                st.markdown(f"**`{filename}`**")
                # Detect language based on filename extension for better syntax highlighting
                lang = "python" if filename.endswith(".py") else \
                       "toml" if filename.endswith(".toml") else \
                       "ini" if filename == ".env" else \
                       "markdown" if filename.endswith(".md") else \
                       "css" if filename.endswith(".css") else \
                       "javascript" if filename.endswith(".js") else \
                       "html" if filename.endswith(".html") else \
                       "text"
                st.code(content, language=lang)

        st.markdown("---")

        # Package project button
        if st.session_state.get("generation_complete", False):
            # Pass ALL files (including any defaults we might have set)
            zip_path = package_project(st.session_state["files"])
            with open(zip_path, "rb") as f:
                st.download_button(
                    "üì¶ Download Full Project (ZIP)",
                    f.read(),
                    file_name="project.zip",
                    mime="application/zip",
                    use_container_width=True
                )
            try:
                os.remove(zip_path)
                shutil.rmtree(os.path.dirname(zip_path)) # Remove the temporary directory
            except Exception as e:
                st.warning(f"Could not fully clean up temporary files: {e}")

        st.markdown("""
        <div style="padding-top: 20px;">
            <h3>How to use your downloaded app:</h3>
            <ol>
                <li>Unzip the downloaded `project.zip` file.</li>
                <li>Follow the instructions in the `README.md` file to install dependencies and set up your Gemini API key.</li>
                <li>Run `streamlit run app.py` in your terminal from the project directory.</li>
            </ol>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.info("No files generated yet. Please go to the 'Chat' tab and describe your app.")

# --- Tab 3: Preview ---
with tab3:
    st.subheader("Live Preview (Local Run Only)")
    st.warning("‚ö° **Important:** The preview feature runs the generated `app.py` locally on your Streamlit instance. It does **not** dynamically run a separate generated Streamlit app *within* this current Streamlit app when deployed on Streamlit Cloud or similar platforms due to sandboxing and security restrictions. This preview is mainly useful during local development of *this* generator app.")

    if "files" in st.session_state and st.session_state["files"]:
        app_content = st.session_state["files"].get("app.py", "")
        if not app_content:
            st.error("`app.py` content is missing from generated files.")
        else:
            st.success("Displaying generated `app.py` code below:")
            st.code(app_content, language="python")

            # Disclaimer for API Key during preview
            if "GEMINI_API_KEY" not in st.secrets or st.secrets["GEMINI_API_KEY"] == "YOUR_GEMINI_API_KEY_HERE":
                st.error("üí° **Gemini API Key Missing:** For a functional preview, ensure your Streamlit secrets (`.streamlit/secrets.toml`) contain a valid `GEMINI_API_KEY`. Or set it in your local `.env` if testing the downloaded project.")

            st.info("The actual 'running' preview requires saving files and executing `streamlit run app.py` in a separate environment, typically your local machine.")

            # Create a temporary directory for the preview app to provide instructions
            tmp_preview_dir = tempfile.mkdtemp()
            # Copy all relevant files for the "how to run" instructions
            for filename, content in st.session_state["files"].items():
                dest_path = os.path.join(tmp_preview_dir, filename)
                with open(dest_path, "w", encoding="utf-8") as f:
                    f.write(content)
            # Add README.md to this temporary dir as well
            with open(os.path.join(tmp_preview_dir, "README.md"), "w", encoding="utf-8") as f:
                f.write(README_CONTENT) # Use the global constant here

            st.markdown(f"""
            <div style="padding: 20px; border: 1px dashed #797C8B; border-radius: 10px; margin-top: 20px;">
                <h3>To run this app yourself for a full preview:</h3>
                <p>These files have been prepared in a temporary directory for you to test locally:</p>
                <pre><code>cd {tmp_preview_dir}</code></pre>
                <p>Then, following the `README.md` instructions:</p>
                <pre><code>pip install -r requirements.txt<br>streamlit run app.py</code></pre>
                <p>Remember to update the `GEMINI_API_KEY` in the `.env` file (if provided) before running!</p>
            </div>
            """, unsafe_allow_html=True)

            # Cleanup for preview files. Providing a button for explicit user action.
            # Using a session state variable to store tmp_preview_dir for cleanup button
            st.session_state["tmp_preview_dir_for_cleanup"] = tmp_preview_dir
            if st.button("Clean up Preview Files", help="Deletes the temporary directory created for the preview (if it exists).", use_container_width=True, key="cleanup_preview_btn"):
                if "tmp_preview_dir_for_cleanup" in st.session_state and os.path.exists(st.session_state["tmp_preview_dir_for_cleanup"]):
                    try:
                        shutil.rmtree(st.session_state["tmp_preview_dir_for_cleanup"])
                        st.success(f"Cleaned up preview directory: {st.session_state['tmp_preview_dir_for_cleanup']}")
                        del st.session_state["tmp_preview_dir_for_cleanup"] # Remove from session state
                    except Exception as e:
                        st.error(f"Error cleaning up preview directory: {e}")
                else:
                    st.info("No temporary preview files to clean up or path not found.")


    else:
        st.info("No app generated yet. Go to the 'Chat' tab to create one!")
