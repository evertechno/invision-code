import streamlit as st
import os
import zipfile
import shutil
import tempfile
import re
from pathlib import Path
import google.generativeai as genai
import textwrap # For better multi-line string handling

# Define readme_content globally
README_CONTENT = """# Generated Streamlit App

This is a Streamlit application generated by Invision Code.AI.

## Setup Instructions:
1.  **Create a virtual environment (optional but recommended):**
    ```bash
    python -m venv venv
    # On macOS/Linux:
    source venv/bin/activate
    # On Windows:
    venv\\Scripts\\activate
    ```
2.  **Install dependencies:**
    ```bash
    pip install -r requirements.txt
    ```
3.  **Set your Gemini API Key (if the app requires it):**
    Edit the `.env` file and replace `YOUR_GEMINI_API_KEY_HERE` with your actual API key.
    You can get an API key from [Google AI Studio](https://aistudio.google.com/app/apikey).
    **Important:** If deploying to Streamlit Cloud, you should add your `GEMINI_API_KEY` to the app's secrets in `.streamlit/secrets.toml` instead of using the `.env` file.
4.  **Run the Streamlit application:**
    ```bash
    streamlit run app.py
    ```
Enjoy your generated app! 🚀
"""

# Common dependencies for a Streamlit + Gemini app
BASE_REQUIREMENTS = {
    "streamlit",
    "python-dotenv", # For loading .env locally
    "google-generativeai" # For Gemini API
}

# ----------------------------------------------------
# Gemini Client (Streamlit settings for API Key)
# ----------------------------------------------------
def get_gemini_client():
    genai.configure(api_key=st.secrets["GEMINI_API_KEY"])
    model = genai.GenerativeModel(
        model_name="gemini-2.5-flash",
        generation_config={
            "temperature": 0.5, # Slightly lower temp for more focused code
            "max_output_tokens": 8192,
        },
        safety_settings=[],
    )
    return model

# ----------------------------------------------------
# Generate Code using Gemini
# ----------------------------------------------------
def generate_code(user_input_prompt: str) -> dict:
    client = get_gemini_client()
    generated_files = {}

    # --- Step 1: Generate app.py first ---
    st.info("🎨 Generating `app.py` code...")
    app_py_prompt = (
        f"You are an expert Streamlit developer. Generate ONLY the Python code "
        f"for a Streamlit application (`app.py` file) based on the following description. "
        f"The code should be complete, runnable, and import any necessary libraries. "
        f"Do NOT include any explanations, comments, or markdown (like ```python) "
        f"around the code unless explicitly part of the app logic itself. "
        f"Ensure `os.environ` is used to fetch API keys like `GEMINI_API_KEY` "
        f"if an LLM is involved. Use `dotenv.load_dotenv()` at the start if using .env for local development.\n\n"
        f"App Description:\n{user_input_prompt}"
    )

    try:
        app_response = client.generate_content([{"role": "user", "parts": [{"text": app_py_prompt}]}])
        app_content = app_response.text.strip()
        # Robustly remove markdown code blocks
        app_content = re.sub(r"```python\s*", "", app_content, count=1).strip()
        app_content = re.sub(r"```\s*$", "", app_content, count=1).strip()

        if app_content:
            generated_files["app.py"] = app_content
            st.success("✅ `app.py` generated.")
        else:
            st.error("⚠️ Gemini returned an empty `app.py` content. Providing a basic default.")
            generated_files["app.py"] = textwrap.dedent("""
                import streamlit as st
                import os
                import dotenv
                dotenv.load_dotenv() # Load environment variables from .env if running locally

                st.set_page_config(page_title='My Generated App')
                st.title('Welcome to your Streamlit App!')
                st.write('This app was generated by Invision Code.AI. Modify app.py to customize.')
                if 'GEMINI_API_KEY' in os.environ and os.environ['GEMINI_API_KEY'] != 'YOUR_GEMINI_API_KEY_HERE':
                    st.success('🎉 Gemini API Key detected! Ready to integrate LLM features.')
                else:
                    st.warning('⚠️ GEMINI_API_KEY not found or is placeholder. Set it in .env or Streamlit secrets for LLM features.')
                # You described: {}
            """.format(user_input_prompt))

    except Exception as e:
        st.error(f"❌ Error generating `app.py`: {e}. Providing a basic default.")
        generated_files["app.py"] = textwrap.dedent("""
            import streamlit as st
            import os
            import dotenv
            dotenv.load_dotenv()

            st.set_page_config(page_title='My Generated App')
            st.title('Welcome to your Streamlit App!')
            st.error('There was an error generating your app.py. Please try again or simplify your request.')
            # Original prompt: {}
            # Error: {}
        """.format(user_input_prompt, e))

    # --- Step 2: Auto-generate requirements.txt based on app.py ---
    st.info("📦 Detecting dependencies for `requirements.txt`...")
    detected_reqs = set()
    # Basic dependency detection: look for `import` statements
    if "app.py" in generated_files:
        app_code = generated_files["app.py"]
        import_pattern = re.compile(r"^\s*import\s+([a-zA-Z_][a-zA-Z0-9_]*)(?:\s+as\s+\w+)?", re.MULTILINE)
        from_import_pattern = re.compile(r"^\s*from\s+([a-zA-Z_][a-zA-Z0-9_.]*)\s+import", re.MULTILINE)

        for match in import_pattern.findall(app_code):
            # Map common imports to their package names if different
            if match == "google.generativeai": # Catch specific multi-part imports too
                 detected_reqs.add("google-generativeai")
            elif "." in match: # for `import sub.module` assume main package is `sub`
                detected_reqs.add(match.split('.')[0])
            else:
                detected_reqs.add(match)

        for match in from_import_pattern.findall(app_code):
            # For `from some_package import X`, add `some_package`
            detected_reqs.add(match.split('.')[0])
            if match == "google.generativeai":
                detected_reqs.add("google-generativeai")
        
        # Ensure 'dotenv' maps to 'python-dotenv'
        if 'dotenv' in detected_reqs:
            detected_reqs.remove('dotenv')
            detected_reqs.add('python-dotenv')


    final_requirements = sorted(list(BASE_REQUIREMENTS.union(detected_reqs)))
    generated_files["requirements.txt"] = "\n".join(final_requirements) + "\n"
    st.success("📝 `requirements.txt` generated.")

    # --- Step 3: Auto-generate .env content ---
    st.info("🔑 Generating `.env` file...")
    # Add dotenv at the start for local loading of .env
    # The default content ensures API key placeholder
    env_content = (
        "# Your Gemini API Key goes here.\n"
        "# Get one from: https://aistudio.google.com/app/apikey\n"
        "GEMINI_API_KEY=YOUR_GEMINI_API_KEY_HERE\n"
    )

    # Check app.py content for other potential env variables the app might need
    # This is a very basic heuristic. A more advanced one might involve another LLM call or deep parsing.
    if "app.py" in generated_files:
        app_code = generated_files["app.py"]
        # Example: looking for `os.environ.get("SOME_VAR")` or `os.getenv("OTHER_VAR")`
        env_var_pattern = re.compile(r"os\.(?:environ\.get|getenv)\(['\"]([A-Z0-9_]+)['\"](?:,.*?)?\)")
        for match in env_var_pattern.findall(app_code):
            if match not in env_content and match not in ["GEMINI_API_KEY", "PYTHON_ENV", "FLASK_ENV", "STREAMLIT_SERVER_PORT"]: # Avoid common or built-in env vars
                env_content += f"\n{match}=YOUR_VALUE_HERE\n"
    
    generated_files[".env"] = env_content.strip() + "\n"
    st.success("📄 `.env` file generated.")


    # --- FINAL CHECK and default for critical files if everything failed ---
    if not generated_files.get("app.py"):
         st.error("❗ Fallback: `app.py` still missing after attempts. Providing ultimate fallback.")
         generated_files["app.py"] = textwrap.dedent("""
            import streamlit as st
            st.title("Generated App - Fallback")
            st.error("The AI failed to generate your app. Please try a simpler prompt or contact support.")
            """)
    if not generated_files.get("requirements.txt"):
        generated_files["requirements.txt"] = "\n".join(BASE_REQUIREMENTS) + "\n"
    if not generated_files.get(".env"):
        generated_files[".env"] = (
            "# Default .env\nGEMINI_API_KEY=YOUR_GEMINI_API_KEY_HERE\n"
        )
            
    return generated_files


# ----------------------------------------------------
# Package files into zip (remains largely the same, but now `files` comes with all content)
# ----------------------------------------------------
def package_project(files: dict) -> str:
    tmpdir = tempfile.mkdtemp()

    for filename, content in files.items():
        # A bit more specific cleanup of potentially generated markdown cruft at beginning/end
        content = re.sub(r"^\s*(# Your.*?here|# Your environment variables go here|# Your Python package dependencies go here)\s*\n", "", content, flags=re.IGNORECASE|re.MULTILINE).strip()
        if content and not content.endswith('\n'):
            content += '\n'
        with open(os.path.join(tmpdir, filename), "w", encoding="utf-8") as f:
            f.write(content)

    with open(os.path.join(tmpdir, "README.md"), "w", encoding="utf-8") as f:
        f.write(README_CONTENT)

    zip_path = os.path.join(tmpdir, "project.zip")
    with zipfile.ZipFile(zip_path, "w") as zipf:
        for root, _, filenames in os.walk(tmpdir):
            for filename in filenames:
                if filename != "project.zip":
                    filepath = os.path.join(root, filename)
                    zipf.write(filepath, arcname=os.path.relpath(filepath, tmpdir))

    return zip_path

# ----------------------------------------------------
# Streamlit UI (Styling and Tabs - remains largely the same)
# ----------------------------------------------------
st.set_page_config(page_title="Invision Code.AI", layout="wide", initial_sidebar_state="collapsed")

st.markdown(
    """
    <style>
    .stApp { background-color: #0E1117; color: white; }
    .stButton>button { background-color: #262730; color: white; border: 1px solid #4F525E; }
    .stButton>button:hover { border-color: #797C8B; color: #797C8B; }
    h1, h2, h3, h4, h5, h6 { color: white; }
    .stMarkdown p { color: white; }
    .streamlit-expanderContent { color: white; }
    code { background-color: #262730; color: #D2A8FF; border-radius: 5px; padding: 0.2em 0.4em; }
    div.stCode > code { border-radius: 0.5rem; padding: 1rem; background-color: #262730; overflow-x: auto; }
    .stTabs [data-baseweb="tab-list"] button [data-testid="stMarkdownContainer"] p { font-size: 1.1em; }
    .stTabs [data-baseweb="tab-list"] button[aria-selected="true"] { background-color: #1a1a2e; border-bottom-color: #E642A2; border-bottom-width: 2px; }
    .stTabs [data-baseweb="tab-list"] button[aria-selected="true"] [data-testid="stMarkdownContainer"] p { color: #E642A2; font-weight: bold; }
    .stTabs [data-baseweb="tab-list"] button[aria-selected="false"] [data-testid="stMarkdownContainer"] p { color: #ADADAD; }
    .stSpinner > div > span { color: white; }
    .stWarning { background-color: rgba(255, 193, 7, 0.1); border-left: 5px solid #ffc107; padding: 1rem; border-radius: 0.25rem; }
    .stError { background-color: rgba(220, 53, 69, 0.1); border-left: 5px solid #dc3545; padding: 1rem; border-radius: 0.25rem; }
    .stSuccess { background-color: rgba(40, 167, 69, 0.1); border-left: 5px solid #28a745; padding: 1rem; border-radius: 0.25rem; }
    .stInfo { background-color: rgba(23, 162, 184, 0.1); border-left: 5px solid #17a2b8; padding: 1rem; border-radius: 0.25rem; }
    </style>
    """,
    unsafe_allow_html=True
)

st.markdown("<h1>💡 Invision Code.AI — Streamlit Application Generator <a href='https://github.com/your-repo-link-here' style='color: inherit; text-decoration: none;'><span style='font-size:0.7em;'>🔗</span></a></h1>", unsafe_allow_html=True)

tab1, tab2, tab3 = st.tabs(["💬 Chat", "📂 Code & Download", "🚀 Preview"])

# --- Tab 1: Chat Interface ---
with tab1:
    st.subheader("Describe the Streamlit app you want to build")
    user_prompt = st.text_area("App Description", height=200, placeholder="E.g., A simple to-do list with add, mark, and delete functionality, using local storage for persistence. Include a graph using matplotlib.", key="chat_prompt")
    if st.button("✨ Generate App Code", use_container_width=True):
        if user_prompt.strip():
            with st.spinner("Generating Streamlit app code with Gemini... This might take a moment."):
                files = generate_code(user_prompt)
                st.session_state["files"] = files
                st.session_state["generation_complete"] = True
                # No success message here as `generate_code` now shows status
                # st.success("Code generation steps completed. Check messages above for details.")
        else:
            st.warning("Please provide a description to generate code.")

# --- Tab 2: Generated Code & Download ---
with tab2:
    st.subheader("Generated Files")
    if "files" in st.session_state and st.session_state["files"]:
        st.info("Here are the generated project files. Download individual files or the whole project as a ZIP.")

        for filename in sorted(st.session_state["files"].keys()):
            content = st.session_state["files"][filename]
            col1, col2 = st.columns([0.2, 0.8])
            with col1:
                st.download_button(
                    f"⬇️ {filename}",
                    data=content.encode("utf-8"),
                    file_name=filename,
                    mime="text/plain",
                    key=f"download_{filename}"
                )
            with col2:
                st.markdown(f"**`{filename}`**")
                lang = "python" if filename.endswith(".py") else \
                       "toml" if filename.endswith(".toml") else \
                       "ini" if filename == ".env" else \
                       "markdown" if filename.endswith(".md") else \
                       "css" if filename.endswith(".css") else \
                       "javascript" if filename.endswith(".js") else \
                       "html" if filename.endswith(".html") else \
                       "text"
                st.code(content, language=lang)

        st.markdown("---")

        if st.session_state.get("generation_complete", False):
            zip_path = package_project(st.session_state["files"])
            with open(zip_path, "rb") as f:
                st.download_button(
                    "📦 Download Full Project (ZIP)",
                    f.read(),
                    file_name="project.zip",
                    mime="application/zip",
                    use_container_width=True
                )
            try:
                os.remove(zip_path)
                shutil.rmtree(os.path.dirname(zip_path))
            except Exception as e:
                st.warning(f"Could not fully clean up temporary files after ZIP: {e}")

        st.markdown("""
        <div style="padding-top: 20px;">
            <h3>How to use your downloaded app:</h3>
            <ol>
                <li>Unzip the downloaded `project.zip` file.</li>
                <li>Follow the instructions in the `README.md` file to install dependencies and set up your Gemini API key.</li>
                <li>Run `streamlit run app.py` in your terminal from the project directory.</li>
            </ol>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.info("No files generated yet. Please go to the 'Chat' tab and describe your app.")

# --- Tab 3: Preview ---
with tab3:
    st.subheader("Live Preview (Local Run Only)")
    st.warning("⚡ **Important:** The preview feature runs the generated `app.py` locally on your Streamlit instance. It does **not** dynamically run a separate generated Streamlit app *within* this current Streamlit app when deployed on Streamlit Cloud or similar platforms due to sandboxing and security restrictions. This preview is mainly useful during local development of *this* generator app.")

    if "files" in st.session_state and st.session_state["files"]:
        app_content = st.session_state["files"].get("app.py", "")
        if not app_content:
            st.error("`app.py` content is missing from generated files.")
        else:
            st.success("Displaying generated `app.py` code below:")
            st.code(app_content, language="python")

            if "GEMINI_API_KEY" not in st.secrets or st.secrets["GEMINI_API_KEY"] == "YOUR_GEMINI_API_KEY_HERE":
                st.error("💡 **Gemini API Key Missing/Placeholder:** For a functional preview, ensure your Streamlit secrets (`.streamlit/secrets.toml`) contain a valid `GEMINI_API_KEY`. Or set it in your local `.env` if testing the downloaded project.")

            st.info("The actual 'running' preview requires saving files and executing `streamlit run app.py` in a separate environment, typically your local machine.")

            tmp_preview_dir = tempfile.mkdtemp()
            for filename, content in st.session_state["files"].items():
                dest_path = os.path.join(tmp_preview_dir, filename)
                with open(dest_path, "w", encoding="utf-8") as f:
                    f.write(content)
            with open(os.path.join(tmp_preview_dir, "README.md"), "w", encoding="utf-8") as f:
                f.write(README_CONTENT) # Use the global constant here

            st.markdown(f"""
            <div style="padding: 20px; border: 1px dashed #797C8B; border-radius: 10px; margin-top: 20px;">
                <h3>To run this app yourself for a full preview:</h3>
                <p>These files have been prepared in a temporary directory for you to test locally:</p>
                <pre><code>cd {tmp_preview_dir}</code></pre>
                <p>Then, following the `README.md` instructions:</p>
                <pre><code>pip install -r requirements.txt<br>streamlit run app.py</code></pre>
                <p>Remember to update the `GEMINI_API_KEY` in the `.env` file (if provided) before running!</p>
            </div>
            """, unsafe_allow_html=True)

            st.session_state["tmp_preview_dir_for_cleanup"] = tmp_preview_dir
            if st.button("Clean up Preview Files", help="Deletes the temporary directory created for the preview (if it exists).", use_container_width=True, key="cleanup_preview_btn"):
                if "tmp_preview_dir_for_cleanup" in st.session_state and os.path.exists(st.session_state["tmp_preview_dir_for_cleanup"]):
                    try:
                        shutil.rmtree(st.session_state["tmp_preview_dir_for_cleanup"])
                        st.success(f"Cleaned up preview directory: {st.session_state['tmp_preview_dir_for_cleanup']}")
                        del st.session_state["tmp_preview_dir_for_cleanup"]
                    except Exception as e:
                        st.error(f"Error cleaning up preview directory: {e}")
                else:
                    st.info("No temporary preview files to clean up or path not found.")

    else:
        st.info("No app generated yet. Go to the 'Chat' tab to create one!")
