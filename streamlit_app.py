import streamlit as st
import os
import zipfile
import shutil
import tempfile
import subprocess
from pathlib import Path
import google.generativeai as genai
# No longer importing 'types' as we're directly structuring content.
# from google.generativeai import types

# ----------------------------------------------------
# Gemini Client (Streamlit settings for API Key)
# ----------------------------------------------------
def get_gemini_client():
    # Configure the API key globally before creating the model
    genai.configure(api_key=st.secrets["GEMINI_API_KEY"])

    # Create the GenerativeModel instance
    # It's good practice to get the model here, but the generation config
    # can also be passed directly to generate_content. For simplicity and consistency,
    # keeping it here for now.
    model = genai.GenerativeModel(
        model_name="gemini-2.5-flash",
        # generation_config here will apply to this model instance by default.
        generation_config={
            "temperature": 0.7, # Lowering temperature might lead to more direct code.
            "max_output_tokens": 8192, # Adjusted for potential longer code. Max is 65535, but typically a smaller token limit for app.py
        },
        safety_settings=[], # Consider adding safety settings based on your needs
    )
    return model

# ----------------------------------------------------
# Generate Code using Gemini
# ----------------------------------------------------
def generate_code(user_input_prompt: str) -> dict: # Renamed parameter for clarity
    client = get_gemini_client()

    # CRITICAL FIX: Make the prompt explicit that we ONLY want Python code for app.py.
    # The current user_input_prompt will be augmented to guide Gemini.
    full_prompt = (
        f"You are an AI code generator. Generate ONLY the Python code for a Streamlit application "
        f"(`app.py` file) based on the following description. Do not include any "
        f"explanations, setup instructions, or markdown beyond the code itself. "
        f"Make sure the code is a complete, runnable `app.py` file.\n\n"
        f"App Description:\n{user_input_prompt}"
    )

    contents = {
        "role": "user",
        "parts": [{"text": full_prompt}],
    }

    response = client.generate_content(contents)
    # Extract the text and remove potential leading/trailing markdown code blocks
    generated_text = response.text.strip()
    if generated_text.startswith("```python") and generated_text.endswith("```"):
        generated_text = generated_text[len("```python"): -len("```")].strip()
    elif generated_text.startswith("```") and generated_text.endswith("```"): # for generic code blocks
        generated_text = generated_text[len("```"): -len("```")].strip()


    return {"app.py": generated_text}

# ----------------------------------------------------
# Package files into zip
# ----------------------------------------------------
def package_project(files: dict) -> str:
    tmpdir = tempfile.mkdtemp()
    for filename, content in files.items():
        # Ensure that content for app.py is handled correctly if it ends up being a path.
        # This part assumes 'content' is the actual string content of the file.
        with open(os.path.join(tmpdir, filename), "w", encoding="utf-8") as f:
            f.write(content)

    # Default files
    with open(os.path.join(tmpdir, "requirements.txt"), "w") as f:
        # Keep consistent with the library name
        f.write("streamlit\npython-dotenv\ngoogle-generativeai\n")

    # Important: Explain to the user where to put their API key
    with open(os.path.join(tmpdir, ".env"), "w") as f:
        f.write("# Your Gemini API Key goes here.\n")
        f.write("# Get one from: https://aistudio.google.com/app/apikey\n")
        f.write("GEMINI_API_KEY=YOUR_GEMINI_API_KEY_HERE\n")

    with open(os.path.join(tmpdir, "README.md"), "w") as f:
        f.write("# Generated Streamlit App\n\n")
        f.write("This is a Streamlit application generated by Invision Code.AI.\n\n")
        f.write("## Setup Instructions:\n")
        f.write("1. **Create a virtual environment (optional but recommended):**\n")
        f.write("   `python -m venv venv`\n")
        f.write("   `source venv/bin/activate` (on macOS/Linux)\n")
        f.write("   `venv\\Scripts\\activate` (on Windows)\n\n")
        f.write("2. **Install dependencies:**\n")
        f.write("   `pip install -r requirements.txt`\n\n")
        f.write("3. **Set your Gemini API Key:**\n")
        f.write("   Edit the `.env` file and replace `YOUR_GEMINI_API_KEY_HERE` with your actual API key.\n")
        f.write("   You can get an API key from [Google AI Studio](https://aistudio.google.com/app/apikey).\n\n")
        f.write("4. **Run the Streamlit application:**\n")
        f.write("   `streamlit run app.py`\n\n")
        f.write("Enjoy your generated app! üöÄ\n")

    zip_path = os.path.join(tmpdir, "project.zip")
    with zipfile.ZipFile(zip_path, "w") as zipf:
        for root, _, filenames in os.walk(tmpdir):
            for filename in filenames:
                if filename != "project.zip": # Don't include the zip file itself in the zip
                    filepath = os.path.join(root, filename)
                    # The arcname is important to ensure files are at the root of the zip
                    # and not in a subdirectory like 'tmpdir/'
                    zipf.write(filepath, arcname=os.path.relpath(filepath, tmpdir))

    return zip_path

# ----------------------------------------------------
# Streamlit Tabs
# ----------------------------------------------------
st.set_page_config(page_title="Invision Code.AI", layout="wide", initial_sidebar_state="collapsed") # collapsed sidebar

st.markdown(
    """
    <style>
    .stApp {
        background-color: #0E1117; /* Dark background matching the image */
        color: white;
    }
    .stButton>button {
        background-color: #262730;
        color: white;
        border: 1px solid #4F525E;
    }
    .stButton>button:hover {
        border-color: #797C8B;
        color: #797C8B;
    }
    h1, h2, h3, h4, h5, h6 {
        color: white;
    }
    .stMarkdown p {
        color: white;
    }
    .streamlit-expanderContent {
        color: white;
    }
    code {
        background-color: #262730; /* Code block background */
        color: #D2A8FF; /* Example code text color */
        border-radius: 5px;
        padding: 0.2em 0.4em;
    }
    div.stCode > code {
        border-radius: 0.5rem; /* Larger border-radius for the whole code block */
        padding: 1rem;
        background-color: #262730;
        overflow-x: auto;
    }
    .stTabs [data-baseweb="tab-list"] button [data-testid="stMarkdownContainer"] p {
        font-size: 1.1em;
    }
    /* Style the active tab text color and border */
    .stTabs [data-baseweb="tab-list"] button[aria-selected="true"] {
        background-color: #1a1a2e; /* slightly lighter dark background for active tab */
        border-bottom-color: #E642A2; /* pink border for active tab */
        border-bottom-width: 2px;
    }
    .stTabs [data-baseweb="tab-list"] button[aria-selected="true"] [data-testid="stMarkdownContainer"] p {
        color: #E642A2; /* pink text for active tab */
        font-weight: bold;
    }
    /* Style inactive tab text color */
    .stTabs [data-baseweb="tab-list"] button[aria-selected="false"] [data-testid="stMarkdownContainer"] p {
        color: #ADADAD; /* grey for inactive tabs */
    }
    .stSpinner > div > span {
        color: white;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.markdown("<h1>üí° Invision Code.AI ‚Äî Streamlit Application Generator <a href='https://github.com/your-repo-link-here' style='color: inherit; text-decoration: none;'><span style='font-size:0.7em;'>üîó</span></a></h1>", unsafe_allow_html=True) # Added a link to a hypothetical GitHub repo

tab1, tab2, tab3 = st.tabs(["üí¨ Chat", "üìÇ Code & Download", "üöÄ Preview"])

# --- Tab 1: Chat Interface ---
with tab1:
    st.subheader("Describe the Streamlit app you want to build")
    user_prompt = st.text_area("App Description", height=200, placeholder="E.g., A simple to-do list with add, mark, and delete functionality, using local storage for persistence.")
    if st.button("‚ú® Generate App Code", use_container_width=True):
        if user_prompt.strip():
            with st.spinner("Generating Streamlit app code with Gemini... This might take a moment."):
                files = generate_code(user_prompt)
                st.session_state["files"] = files
                st.session_state["generation_complete"] = True # Set a flag
                st.success("Code generated! Now go to the 'Code & Download' tab.")
                # Optionally, switch to the code tab automatically (advanced, requires JS injection or direct tab change logic)
        else:
            st.warning("Please provide a description to generate code.")

# --- Tab 2: Generated Code & Download ---
with tab2:
    st.subheader("Generated Files")
    if "files" in st.session_state and st.session_state["files"]:
        st.info("The generated `app.py` code is shown below. You can download individual files or the whole project as a ZIP.")

        for filename, content in st.session_state["files"].items():
            col1, col2 = st.columns([0.2, 0.8])
            with col1:
                st.download_button(
                    f"‚¨áÔ∏è {filename}", # Added emoji for clarity
                    data=content,
                    file_name=filename,
                    mime="text/plain",
                    key=f"download_{filename}"
                )
            with col2:
                # Optionally add a small header for each file if there were multiple
                st.markdown(f"**`{filename}`**")
                st.code(content, language="python" if filename.endswith(".py") else "text")

        st.markdown("---") # Separator

        # Package project button
        if st.session_state.get("generation_complete", False):
            # Only package when needed and when content is available
            zip_path = package_project(st.session_state["files"])
            with open(zip_path, "rb") as f:
                st.download_button(
                    "üì¶ Download Full Project (ZIP)",
                    f.read(),
                    file_name="project.zip",
                    mime="application/zip",
                    use_container_width=True
                )
            # Clean up the temporary zip file after download if possible (Streamlit limitation: usually kept until script rerun)
            # If using st.cache_data, might need a more explicit cleanup strategy.
            try:
                os.remove(zip_path) # Attempt to remove the generated zip
                shutil.rmtree(os.path.dirname(zip_path)) # Remove the temporary directory
            except Exception as e:
                st.warning(f"Could not fully clean up temporary files: {e}")

        st.markdown("""
        <div style="padding-top: 20px;">
            <h3>How to use your downloaded app:</h3>
            <ol>
                <li>Unzip the downloaded `project.zip` file.</li>
                <li>Follow the instructions in the `README.md` file to install dependencies and set up your Gemini API key.</li>
                <li>Run `streamlit run app.py` in your terminal from the project directory.</li>
            </ol>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.info("No files generated yet. Please go to the 'Chat' tab and describe your app.")

# --- Tab 3: Preview ---
with tab3:
    st.subheader("Live Preview (Local Run Only)")
    st.warning("‚ö° **Important:** The preview feature runs the generated `app.py` locally on your Streamlit instance. It does **not** dynamically run a separate generated Streamlit app *within* this current Streamlit app when deployed on Streamlit Cloud or similar platforms due to sandboxing and security restrictions. This preview is mainly useful during local development of *this* generator app.")

    if "files" in st.session_state and st.session_state["files"]:
        app_content = st.session_state["files"].get("app.py", "")
        if not app_content:
            st.error("`app.py` content is missing from generated files.")
        else:
            st.success("Displaying generated `app.py` code below:")
            st.code(app_content, language="python")

            # Disclaimer for API Key during preview
            if "GEMINI_API_KEY" not in st.secrets or st.secrets["GEMINI_API_KEY"] == "your-generated-app-key":
                st.error("üí° **Gemini API Key Missing:** For a functional preview, ensure your Streamlit secrets (`.streamlit/secrets.toml`) contain a valid `GEMINI_API_KEY`.")

            # Create a temporary directory for the preview app
            tmp_preview_dir = tempfile.mkdtemp()
            app_file_path = os.path.join(tmp_preview_dir, "app.py")
            requirements_file_path = os.path.join(tmp_preview_dir, "requirements.txt")
            env_file_path = os.path.join(tmp_preview_dir, ".env")


            try:
                # Write app.py
                with open(app_file_path, "w", encoding="utf-8") as f:
                    f.write(app_content)

                # Write minimal requirements.txt
                with open(requirements_file_path, "w", encoding="utf-8") as f:
                    f.write("streamlit\n")
                    f.write("google-generativeai\n") # Assuming most apps will use this
                    # Add any other common deps or try to infer from app_content

                # Write a placeholder .env if not using secrets, or if it might be useful for local run
                with open(env_file_path, "w", encoding="utf-8") as f:
                    if "GEMINI_API_KEY" in st.secrets and st.secrets["GEMINI_API_KEY"] != "your-generated-app-key":
                         f.write(f"GEMINI_API_KEY={st.secrets['GEMINI_API_KEY']}\n")
                    else:
                         f.write("GEMINI_API_KEY=YOUR_GEMINI_API_KEY_HERE # Fill this for local test if needed\n")

                # You can try to run it in a subprocess and display its output or status
                # However, running a full Streamlit app *inside* another Streamlit app's iframe is complex and limited.
                # A more realistic "preview" in this context is often just displaying the code and explaining how to run it.

                # If you genuinely wanted to *run* it and display output, you'd launch it
                # as a separate process and embed an iframe to its localhost address.
                # This requires that your Streamlit generator itself is running on a server that allows this,
                # and often needs to expose a port for the sub-app. This is beyond typical Streamlit cloud capabilities.
                #
                # For this application, displaying the code and giving instructions is the most reliable "preview."
                st.markdown(f"""
                <div style="padding: 20px; border: 1px dashed #797C8B; border-radius: 10px; margin-top: 20px;">
                    <h3>To run this preview locally on your machine:</h3>
                    <p>Open a new terminal, navigate to this project's temporary preview directory:</p>
                    <pre><code>cd {tmp_preview_dir}<br>streamlit run app.py</code></pre>
                    <p>Then open the provided URL in your browser.</p>
                </div>
                """, unsafe_allow_html=True)


            except Exception as e:
                st.error(f"Error preparing preview: {e}")
            finally:
                # Attempt to clean up the temporary preview directory
                # This might not execute immediately depending on Streamlit's lifecycle
                pass # Delay cleanup, or provide a button

        # Add a cleanup button for the temporary preview files
        if st.button("Clean up Preview Files", help="Deletes the temporary directory created for the preview.", use_container_width=True):
            if "tmp_preview_dir" in locals() and os.path.exists(tmp_preview_dir):
                try:
                    shutil.rmtree(tmp_preview_dir)
                    st.success(f"Cleaned up preview directory: {tmp_preview_dir}")
                except Exception as e:
                    st.error(f"Error cleaning up preview directory {tmp_preview_dir}: {e}")
            else:
                st.info("No temporary preview files to clean up or path not found.")

    else:
        st.info("No app generated yet. Go to the 'Chat' tab to create one!")
